#!/usr/bin/env python3
import sys
import os
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Gio, Gdk
import subprocess
from shutil import copyfile
from pathlib import Path
import re

# Define the path to css file
css_file = Path('~/.config/gtk-3.0/gtk.css').expanduser()

class Opacity:
    TOP = 1
    MIDDLE = 0.70
    LOW = 0.45

layouts = [
    { 'id':'manjaro', 'label':'Manjaro', 'x':1, 'y':0},
    { 'id':'win', 'label':'Windows', 'x':2, 'y':0},
    { 'id':'mac', 'label':'MacOs', 'x':1, 'y':3},
    { 'id':'gnome', 'label':'Gnome', 'x':2, 'y':3},
]

class Backend:
    admin = False

    @classmethod
    def check(cls, **kwargs):
        """
        check sys.argv  or
        check if Admin  or
        check file exists  or
        check manjaro / good DE  or ...
        """
        if not cls.admin and os.geteuid() == 0:
            raise PermissionError(f"Never run this action {cls.__name__} as Admin")
        return 0

    def apply(self, **kwargs):
        raise RuntimeError("Backend not yet implemented")

    @staticmethod
    def execute(command: str):
        """ generic shell call
            :return tuple (code, stdout, stderr)
        """
        proc = subprocess.run(command, shell=True, universal_newlines=True, capture_output=True)
        print("\n :: execute returncode:", proc.returncode)
        print(" :: execute out:", proc.stdout)
        print(" :: execute err:", proc.stderr, "\n")
        return proc.returncode, proc.stdout, proc.stderr

    def run(self, **kwargs):
        """ subprocess.run() """
        #name=kwargs.get('name', None)
        err_code = self.check(**kwargs)
        print("err_code check() =", err_code)
        if err_code > 0:
            return err_code
        return self.apply(**kwargs)

    def load(self, **kwargs):
        """ fonction for GUI """
        if not self.admin:
            # direct run
            return self.run(**kwargs)
        # else uses pkexec self app with same parameters
        params = ''
        for key, value in kwargs.items():
            params = f"{params} -{key} {str(value)}"
        fileexe = Path(sys.argv[0]).resolve()

        print("as Admin, run:", f"pkexec {fileexe} --admin --{self.sign} -{params}")
        proc = subprocess.run(f"pkexec {fileexe} --admin --{self.sign} {params}", shell=True)
        return proc.returncode

    @property
    def sign(self):
        return self.__class__.__name__

    @staticmethod
    def mainConsole():
        """ run as Admin in console """
        print("---mainConsole --- ? ", sys.argv)
        if '--admin' in sys.argv:
            args = sys.argv[2:]
            sign = args.pop(0)[2:]
            print("want run action:", sign)
            if not str(sign).startswith('Backend'):
                raise RuntimeError(f"Action {sign} not implemented") # run only backend object
            if not sign in globals():
                raise RuntimeError(f"Action {sign} not exists")

            print('As admin, we run params:', sys.argv)
            args = {x[1:]: args[args.index(x)+1] for x in args if args.index(x) % 2 == 0}
            print("params pass to run(): ", args)
            action_class = globals()[sign]
            action = action_class()     # create object from second console parameter
            err_code = action.run(**args)
            print("   -> return code is:", err_code)
            exit(err_code)
        else:
            print("debug info: Not admin, we use gui ...")

class BackendTheme(Backend):
    def apply(self, **kwargs):
        name = kwargs.get('theme')
        print("Apply user theme : ", self.__class__.__name__, "switch to:", name, "\n\n")
        code, out, err = self.execute('ls -l')
        code, out, err = self.execute('stat /root/.')
        return code

class BackendWayland(Backend):
    admin = True    # backend use pkexec
    file_config = "/etc/gdm/custom.conf"

    @classmethod
    def check(self, **kwargs):
        """
        test if DE support wayland for example and/or file exists
        can use in gui for display on not btn :
            if BackendWayland.check() == 0: createBtn()
        """
        super().check(**kwargs)
        print("BackendWayland.check()")
        if not Path(self.file_config).exists():
            pass
            #return 99 # TODO un-comment use it

        print('check kwargs: ', kwargs)
        if kwargs:
            if not kwargs.get('setstate') in ['on', 'off']:
                print("DEBUG, ERROR: expected parameter wayland !")
                return 1
        return 0

    def apply(self, **kwargs):
        if self.admin and os.geteuid() != 0:
            raise PermissionError(f"Never run this action {self.sign} as user")

        wayland_state = kwargs.get('setstate')
        print("debug Apply: ", self.sign, "switch to:", wayland_state)
        # TODO use pure python open(gdm.conf), write(gdm.conf)...
        commands = 'sed -i "s/^WaylandEnable=false/#WaylandEnable=false/" /etc/gdm/custom.conf'
        if wayland_state == 'on':
            commands = 'sed -i "s/^#WaylandEnable=false/WaylandEnable=false/" /etc/gdm/custom.conf'
        '''
        NOT RUN for this moment in test
        code, _, err_msg = self.execute(commands)
        if code > 0:
            print("oops, error:", err_msg)'''
        code, _, _ = self.execute('stat /root/.') # only for test
        return code

print("\nos.geteuid() :", os.geteuid())

Backend.mainConsole()
if os.geteuid() == 0:
    print("\nDEBUG: this script is now call as Admin\n")

##########
# TESTS backend without pkexec
#####"####

# actions in gui, but user
action = BackendTheme()
err_code = action.load(theme='manjaro', param2='test')

print("wayland support ?", BackendWayland.check() == 0)
# action in gui, but Admin
action = BackendWayland()
err_code = action.load(setstate='on')
exit(err_code)

# end TESTS

def rm_brand():
    commands = ['pamac-installer --remove manjaro-gnome-assets manjaro-gdm-branding',
    'grep -q \'@define-color theme_selected_bg_color\' ~/.config/gtk-3.0/gtk.css && mv ~/.config/gtk-3.0/gtk.css ~/.config/gtk-3.0/gtk.css.bak']
    for cmd in commands:
        subprocess.run(cmd, shell=True)

def rebrand():
    commands = ['pamac-installer manjaro-gnome-assets manjaro-gdm-branding',
    'grep -q \'@define-color theme_selected_bg_color\' ~/.config/gtk-3.0/gtk.css || cp /usr/share/gtk-3.0/gtk.css ~/.config/gtk-3.0/gtk.css']
    for cmd in commands:
        subprocess.run(cmd, shell=True)

def enable_wayland():
    commands = ['pkexec sed -i "s/^WaylandEnable=false/#WaylandEnable=false/" /etc/gdm/custom.conf']
    for cmd in commands:
        subprocess.run(cmd, shell=True)

def disable_wayland():
    commands = ['pkexec sed -i "s/^#WaylandEnable=false/WaylandEnable=false/" /etc/gdm/custom.conf']
    for cmd in commands:
        subprocess.run(cmd, shell=True)

def set_highlight_color(new_color):
    # If not present, copy the file from default
    if not Path.is_file(css_file):
        copyfile('/usr/share/gtk-3.0/gtk.css', css_file)
    # Find the current highlight color
    with open(css_file) as f:
        file = f.read()
        current_color = re.search("^@define-color.*theme_selected_bg_color.*#(.*)", file)
        current_color = current_color.group(0)[38:-1]
        # Replace the old color with new one
    with open(css_file) as f:
        newText=f.read().replace(current_color, new_color, 2)
    # Write the changes
    with open(css_file, "w") as f:
        f.write(newText)

class HeaderBarWindow(Gtk.Window):
        
    def __init__(self):
        self.layout = 'manjaro'
        Gtk.Window.__init__(self, title="Gnome Layout Switcher")
        self.set_border_width(1)
        # self.set_default_size(300, 300)

        hb = Gtk.HeaderBar()
        hb.set_show_close_button(True)
        hb.props.title = "Layout Switcher"
        self.set_titlebar(hb)
        
        vbox = Gtk.Grid(row_homogeneous=False, column_homogeneous=False, row_spacing=0, margin_left=0, margin_right=0, margin_bottom=1, margin_top=0)
        self.add(vbox)
        # Stack settings
        stack = Gtk.Stack()
        stack.set_transition_type(Gtk.StackTransitionType.SLIDE_LEFT_RIGHT)
        stack.set_transition_duration(300)
        stack.set_hhomogeneous(False)
        stack.set_vhomogeneous(False)
        stack.set_vexpand(True)
        stack.props.valign = Gtk.Align.START

        # Layout menu
        radiobox = Gtk.Grid(column_spacing=45, row_spacing=15, margin_left=10, margin_right=10, margin_bottom=0, margin_top=15)
        radiobox.set_hexpand(True)
        radiobox.props.halign = Gtk.Align.CENTER
        self.btn_layout_first = None
        for layout in layouts:
            self.create_layout_btn(layout=layout , the_grid=radiobox)
                # A button to apply the settings
        applybutton = Gtk.Button.new_with_label("Apply")
        applybutton.connect("clicked", self.on_click_me_clicked)
        radiobox.attach(applybutton, 1, 6, 2, 1)
        applybutton.props.valign = Gtk.Align.END

        stack.add_titled(radiobox, "radiobox", "Layout")
        stack.props.margin_bottom = 0
        stack_switcher = Gtk.StackSwitcher()
        stack_switcher.set_stack(stack)
        stack_switcher.set_hexpand(True)
        stack_switcher.props.halign = Gtk.Align.CENTER

        ## The theme tab
        theme_grid = Gtk.Grid(row_spacing=20, margin_left=40, margin_right=40, margin_bottom=0, margin_top=15)
        theme_grid.set_hexpand(False)
        theme_grid.props.valign = Gtk.Align.START
        theme_grid.set_vexpand(True)
        stack.add_titled(theme_grid, "theme_grid", "Theme")

        # Manjaro branding toggle
        manjaro_switch = Gtk.Switch()
        branding_enabled = subprocess.run('pacman -Qq manjaro-gnome-assets &>/dev/null', shell=True)
        if branding_enabled.returncode == 0:
            manjaro_switch.set_active(True)
        else:
            manjaro_switch.set_active(False)
        manjaro_switch.connect("notify::active", self.on_branding_activated)
        manjaro_label = Gtk.Label()
        manjaro_label.set_markup("        Manjaro branding")
        manjaro_label.props.halign = Gtk.Align.START

        # wayland toggle
        wayland_switch = Gtk.Switch()
        wayland_enabled = subprocess.run('grep -q "^WaylandEnable=false" /etc/gdm/custom.conf', shell=True)
        if wayland_enabled.returncode == 1:
            wayland_switch.set_active(True)
        else:
            wayland_switch.set_active(False)
        wayland_switch.connect("notify::active", self.on_wayland_activated)
        wayland_label = Gtk.Label()
        wayland_label.set_markup("        Wayland session")
        wayland_label.props.halign = Gtk.Align.START

        theme_button = Gtk.Button.new_with_label("Open")
        theme_button.connect("clicked", self.on_button_activated)
        theme_label = Gtk.Label()
        theme_label.set_markup("        Theme settings")
        theme_label.props.halign = Gtk.Align.START

        # Color picker
        self.color_button = Gtk.ColorButton()
        # with a default color (blue, in this instance)
        if Path.is_file(css_file):
            with open(css_file) as f:
                file = f.read()
                current_color = re.search("^@define-color.*theme_selected_bg_color.*#(.*)", file)
                current_color = current_color.group(0)[38:-1]
        else:
            current_color = '#16a085'
        color = Gdk.RGBA()
        color.parse(current_color)
        color.to_string()
        self.color_button.set_rgba(color)

        color_label = Gtk.Label()
        color_label.set_markup("        Application highlight color")
        color_label.props.halign = Gtk.Align.START
        # choosing a color in the dialogue window emits a signal
        self.color_button.connect("color-set", self.on_color_chosen)

        # Theme tab layout
        theme_grid.attach(theme_button, 1, 0, 1, 1)
        theme_grid.attach(theme_label, 3, 0, 2, 1)
        theme_grid.attach(manjaro_switch, 1, 1, 1, 1)
        theme_grid.attach(manjaro_label, 3, 1, 2, 1)
        theme_grid.attach(wayland_switch, 1, 2, 1, 1)
        theme_grid.attach(wayland_label, 3, 2, 2, 1)
        theme_grid.attach(self.color_button, 1, 3, 1, 1)
        theme_grid.attach(color_label, 3, 3, 2, 1)

        # Pack everything to a box
        vbox.attach(stack_switcher, 1, 0, 1, 1)
        vbox.attach(stack,  1, 1, 1, 3)
    # Create the desktop grid
    def create_layout_btn(self, layout, the_grid):
        btn = Gtk.RadioButton.new_with_label_from_widget(self.btn_layout_first, layout['label'])
        if not self.btn_layout_first:
            self.btn_layout_first = btn
        btn.connect("toggled", self.on_button_toggled, layout['id'])
        the_grid.attach(btn, layout['x'], layout['y'], 1, 1)
        # Set preview images
        resDirectory = Path('../data').resolve()   # only if we use git, path exists 
        if not resDirectory.exists():
            resDirectory = '/usr/share/gls'    # use installed dir by pacman
        preview_img = Gtk.Image()
        preview_img.set_from_file(f"{resDirectory}/pictures/{layout['id']}preview.png")
        btn.image = preview_img  # link img to checkbox for easy find
        # reduce opacity of de-selected previews
        if btn.get_active():
            preview_img.set_opacity(1)
        else:
            preview_img.set_opacity(0.65)
        # make preview images clickable
        event_img = Gtk.EventBox()
        event_img.connect("button-release-event",self.on_click_img)  # click in box
        event_img.connect("enter-notify-event",self.on_over_img, True)  # mouse over box
        event_img.connect("leave-notify-event",self.on_over_img, False)  # mouse out box
        event_img.add(preview_img)    # add img in box
        event_img.btn = btn    # link btn to box for easy find
        the_grid.attach(event_img, layout['x'], layout['y']+1, 1, 1) # add box and not img in grid

    # placeholder functions
    def on_button_toggled(self, button, name):
        state = Opacity.LOW
        if button.get_active():
            state = Opacity.TOP
            self.layout = name
            print('active layout:', self.layout)
        button.image.set_opacity(state)    # change img opacity from state
    def on_over_img(self, box, event, isOverImage):
        """on mouse over / out : change opacity"""
        if box.btn.get_active():
            return
        if isOverImage:
            box.btn.image.set_opacity(Opacity.MIDDLE)
        else:
            box.btn.image.set_opacity(Opacity.LOW)

    def on_color_chosen(self, user_data):
        col = self.color_button.get_rgba().to_string()[4:-1:]
        # convert color to hexadecimal
        col = col.split(',')
        col = ( int(x) for x in col )
        col = '#%02x%02x%02x' % tuple(col)
        set_highlight_color(col)
        
    def on_wayland_activated(self, switch, gparam):
        if switch.get_active():
            state = "on"
            enable_wayland()
        else:
            state = "off"
            disable_wayland()
        print("Wayland was turned", state)

    def on_branding_activated(self, switch, gparam):
        if switch.get_active():
            state = "on"
            rebrand()
        else:
            state = "off"
            rm_brand()
        print("Branding was turned", state)

    def on_button_activated(self, button):
        cmd = 'gnome-tweaks &'
        subprocess.run(cmd, shell=True)

    # Make images clickable
    def on_click_img(self, box, event):
        box.btn.set_active(True) # change checkbox state and call on_button_toggled()

    def on_click_me_clicked(self, button):
        commands = {
            'manjaro': [
                'gsettings set org.gnome.shell enabled-extensions "[\'dash-to-dock@micxgx.gmail.com\', \'user-theme@gnome-shell-extensions.gcampax.github.com\', \'drive-menu@gnome-shell-extensions.gcampax.github.com\', \'appindicatorsupport@rgcjonas.gmail.com\', \'pamac-updates@manjaro.org\', \'arc-menu@linxgem33.com\']"',
                'gsettings set org.gnome.shell.extensions.dash-to-dock dock-position LEFT',
                'gsettings set org.gnome.shell.extensions.dash-to-dock extend-height true',
                'gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed true',
                'gsettings set org.gnome.shell.extensions.arc-menu menu-button-text "Custom_Text"',
                'gsettings set org.gnome.shell.extensions.arc-menu custom-menu-button-text " Menu"',
                'gsettings set org.gnome.desktop.wm.preferences button-layout ":minimize,maximize,close"',
            ],
            'win': [
                'gsettings set org.gnome.shell enabled-extensions "[\'dash-to-panel@jderose9.github.com\', \'user-theme@gnome-shell-extensions.gcampax.github.com\', \'appindicatorsupport@rgcjonas.gmail.com\', \'pamac-updates@manjaro.org\', \'arc-menu@linxgem33.com\']"',
                'gsettings --schemadir /usr/share/gnome-shell/extensions/dash-to-panel@jderose9.github.com/schemas set org.gnome.shell.extensions.dash-to-panel show-show-apps-button false',
                'gsettings set org.gnome.shell.extensions.arc-menu menu-button-text "Custom_Text"',
                'gsettings set org.gnome.shell.extensions.arc-menu custom-menu-button-text " "',
                'gsettings set org.gnome.desktop.wm.preferences button-layout ":minimize,maximize,close"'
            ],
            'mac' : [
                'gsettings set org.gnome.shell enabled-extensions "[\'dash-to-dock@micxgx.gmail.com\', \'user-theme@gnome-shell-extensions.gcampax.github.com\', \'unite@hardpixel.eu\', \'pamac-updates@manjaro.org\']"',
                'gsettings set org.gnome.shell.extensions.dash-to-dock dock-position BOTTOM',
                'gsettings set org.gnome.shell.extensions.dash-to-dock extend-height false',
                'gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed false',
                'gsettings set org.gnome.desktop.wm.preferences button-layout "close,minimize,maximize:"'
            ],
            'gnome' : [
                'gsettings set org.gnome.shell enabled-extensions "[\'pamac-updates@manjaro.org\', \'user-theme@gnome-shell-extensions.gcampax.github.com\']"',
                'gsettings set org.gnome.desktop.wm.preferences button-layout ":minimize,maximize,close"'
            ]
        }

        for cmd in commands.get(self.layout, ""):
            subprocess.run(cmd, shell=True)
        print("Layout applied")




# Show the window        
win = HeaderBarWindow()
win.connect("destroy", Gtk.main_quit)
win.show_all()
Gtk.main()
